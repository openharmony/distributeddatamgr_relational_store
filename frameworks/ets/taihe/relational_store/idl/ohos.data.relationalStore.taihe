/*
 * Copyright (c) 2025-2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.data.relationalStore", "relationalStore")

@!sts_inject_into_module("""
import BaseContext from 'application.BaseContext';
import dataSharePredicates from '@ohos.data.dataSharePredicates';
import { AsyncCallback } from '@ohos.base';
""")

@!sts_inject("""
static { loadLibraryWithPermissionCheck("relationalstore_ani.z", "@ohos.data.relationalStore"); }
""")

enum AssetStatus: i32 {
    ASSET_NORMAL = 1,
    ASSET_INSERT,
    ASSET_UPDATE,
    ASSET_DELETE,
    ASSET_ABNORMAL,
    ASSET_DOWNLOADING
}

struct Asset {
    name: String;
    uri: String;
    path: String;
    createTime: String;
    modifyTime: String;
    size: String;
    status: Optional<AssetStatus>;
}

union ValueType {
    @null EMPTY;
    INT64: i64;
    F64: f64;
    STRING: String;
    BOOL: bool;
    Uint8Array: @typedarray Array<u8>;
    ASSET: Asset;
    ASSETS: Array<Asset>;
    Float32Array: @typedarray Array<f32>;
    bigint: @bigint Array<u64>;
}

union ValuesBucket {
    VALUESBUCKET : @record Map<String, ValueType>;
}

union PRIKeyType {
    INT64: i64;
    STRING: String;
    F64: f64;
}

union ModifyTime {
    MODIFYTIME : @record Map<PRIKeyType, @sts_type("Date") Opaque>;
}

struct StoreConfig {
    name: String;
    securityLevel: SecurityLevel;
    encrypt: Optional<bool>;
    dataGroupId: Optional<String>;
    customDir: Optional<String>;
    rootDir: Optional<String>;
    autoCleanDirtyData: Optional<bool>;
    isSearchable: Optional<bool>;
    allowRebuild: Optional<bool>;
    vector: Optional<bool>;
    isReadOnly: Optional<bool>;
    pluginLibs: Optional<Array<String>>;
    haMode: Optional<HAMode>;
    cryptoParam: Optional<CryptoParam>;
    tokenizer: Optional<Tokenizer>;
    persist: Optional<bool>;
    enableSemanticIndex: Optional<bool>;
}

enum HAMode: i32 {
    SINGLE = 0,
    MAIN_REPLICA
}

struct CryptoParam {
    encryptionKey: @typedarray Array<u8>;
    iterationCount: Optional<i32>;
    encryptionAlgo: Optional<EncryptionAlgo>;
    hmacAlgo: Optional<HmacAlgo>;
    kdfAlgo: Optional<KdfAlgo>;
    cryptoPageSize: Optional<u32>;
}

enum EncryptionAlgo: i32 {
    AES_256_GCM = 0,
    AES_256_CBC,
    PLAIN_TEXT
}

enum HmacAlgo: i32 {
    SHA1 = 0,
    SHA256,
    SHA512
}

enum KdfAlgo: i32 {
    KDF_SHA1 = 0,
    KDF_SHA256,
    KDF_SHA512
}

enum Progress: i32 {
    SYNC_BEGIN,
    SYNC_IN_PROGRESS,
    SYNC_FINISH
}

struct Statistic {
    total: u32;
    successful: u32;
    failed: u32;
    remained: u32;
}

struct TableDetails {
    upload: Statistic;
    download: Statistic;
}

enum ProgressCode: i32 {
    SUCCESS,
    UNKNOWN_ERROR,
    NETWORK_ERROR,
    CLOUD_DISABLED,
    LOCKED_BY_OTHERS,
    RECORD_LIMIT_EXCEEDED,
    NO_SPACE_FOR_ASSET,
    BLOCKED_BY_NETWORK_STRATEGY
}

struct ProgressDetails {
    schedule: Progress;
    code: ProgressCode;
    details: @record Map<String, TableDetails>;
}

struct SqlExecutionInfo {
    sql: Array<String>;
    totalTime: i64;
    waitTime: i64;
    prepareTime: i64;
    executeTime: i64;
}

enum SecurityLevel: i32 {
    S1 = 1,
    S2 = 2,
    S3 = 3,
    S4 = 4
}

enum SyncMode : i32 {
    SYNC_MODE_PUSH = 0,
    SYNC_MODE_PULL = 1,
    SYNC_MODE_TIME_FIRST = 4,
    SYNC_MODE_NATIVE_FIRST,
    SYNC_MODE_CLOUD_FIRST
}

enum SubscribeType : i32 {
    SUBSCRIBE_TYPE_REMOTE = 0,
    SUBSCRIBE_TYPE_CLOUD,
    SUBSCRIBE_TYPE_CLOUD_DETAILS,
    SUBSCRIBE_TYPE_LOCAL_DETAILS
}

enum ChangeType : i32 {
    DATA_CHANGE,
    ASSET_CHANGE
}

struct ChangeInfo {
    table: String;
    type: ChangeType;
    inserted: StringOrNumberArray;
    updated: StringOrNumberArray;
    deleted: StringOrNumberArray;
}

enum DistributedType : i32 {
    DISTRIBUTED_DEVICE,
    DISTRIBUTED_CLOUD
}

struct Reference {
    sourceTable: String;
    targetTable: String;
    refFields: @record Map<String, String>;
}

struct DistributedConfig {
    autoSync: bool;
    references: Optional<Array<Reference>>;
    asyncDownloadAsset: Optional<bool>;
    enableCloud: Optional<bool>;
}

enum ConflictResolution  : i32 {
    ON_CONFLICT_NONE = 0,
    ON_CONFLICT_ROLLBACK = 1,
    ON_CONFLICT_ABORT = 2,
    ON_CONFLICT_FAIL = 3,
    ON_CONFLICT_IGNORE = 4,
    ON_CONFLICT_REPLACE = 5
}

enum Origin : i32 {
    LOCAL,
    CLOUD,
    REMOTE,
}

enum Field : String {
    CURSOR_FIELD = "#_cursor",
    ORIGIN_FIELD = "#_origin",
    DELETED_FLAG_FIELD = "#_deleted_flag",
    DATA_STATUS_FIELD = "#_data_status",
    OWNER_FIELD = "#_cloud_owner",
    PRIVILEGE_FIELD = "#_cloud_privilege",
    SHARING_RESOURCE_FIELD = "#_sharing_resource_field"
}

enum RebuildType : i32  {
    NONE,
    REBUILT,
    REPAIRED
}

enum TransactionType : i32  {
    DEFERRED,
    IMMEDIATE,
    EXCLUSIVE
}

struct ReturningConfig {
    columns: Array<String>;
    maxReturningCount: Optional<i32>;
}

struct Result {
    changed: i64;
    resultSet: LiteResultSet;
}

struct TransactionOptions {
    transactionType: Optional<TransactionType>;
}

struct ExceptionMessage {
    code: i32;
    message: String;
    sql: String;
}

struct SqlInfo {
    sql: String;
    args: Array<ValueType>;
}

union StringOrNumberArray {
    STRINGARRAY : Array<String>;
    Int64Array : Array<i64>;
}

union ColumnIdentifier {
    columnIndex : i32;
    columnName : String;
}

@!sts_inject("""
enum ColumnType {
    NULL,
    INTEGER,
    REAL,
    TEXT,
    BLOB,
    ASSET,
    ASSETS,
    FLOAT_VECTOR,
    UNLIMITED_INT,
  }
""")

enum Tokenizer : i32 {
    NONE_TOKENIZER = 0,
    ICU_TOKENIZER,
    CUSTOM_TOKENIZER
}

interface ResultSet {
    GetProxy (): i64;

    @get GetColumnCount() : i32;

    @get GetRowCount() : i32;

    @get GetRowIndex() : i32;

    @get GetIsAtFirstRow() : bool;

    @get GetIsAtLastRow() : bool;

    @get GetIsEnded() : bool;

    @get GetIsStarted() : bool;

    @get GetIsClosed() : bool;

    @get("columnNames") GetAllColumnNames() : Array<String>;

    GetColumnNames(): Array<String>;

    GetColumnIndex(columnName: String): i32;

    GetColumnName(columnIndex: i32): String;

    @gen_promise("getColumnType")
    GetColumnTypeSync(columnIdentifier: ColumnIdentifier): @sts_type("ColumnType") Opaque;

    GoTo(offset: i32): bool;

    GoToRow(position: i32): bool;

    GoToFirstRow(): bool;

    GoToLastRow(): bool;

    GoToNextRow(): bool;

    GoToPreviousRow(): bool;

    GetBlob(columnIndex: i32): @typedarray Array<u8>;

    GetString(columnIndex: i32): String;

    GetLong(columnIndex: i32): i64;

    GetDouble(columnIndex: i32): f64;

    GetAsset(columnIndex: i32): Asset;

    GetAssets(columnIndex: i32): Array<Asset>;

    GetValue(columnIndex: i32): ValueType;

    GetFloat32Array(columnIndex: i32): @typedarray Array<f32>;

    GetRow(): @record Map<String, ValueType>;

    @gen_promise("getRows")
    GetRowsSync(maxCount: i32, position: Optional<i32>): Array<ValuesBucket>;

    GetCurrentRowData(): Array<ValueType>;

    @gen_promise("getRowsData")
    GetRowsDataSync(maxCount: i32, position: Optional<i32>): Array<Array<ValueType>>;

    IsColumnNull(columnIndex: i32): bool;

    Close(): void;
}

@class
interface LiteResultSet {
    GetProxy (): i64;
    @gen_promise("getRows")
    GetRowsSync(maxCount: i32, position: Optional<i32>): Array<@record Map<String, ValueType>>;
    GetColumnIndex(columnName: String): i32;
    GetColumnName(columnIndex: i32): String;
    GetColumnNames(): Array<String>;
    GoToNextRow(): bool;
    GetBlob(columnIndex: i32): @typedarray Array<u8>;
    GetString(columnIndex: i32): String;
    GetLong(columnIndex: i32): i64;
    GetDouble(columnIndex: i32): f64;
    GetAsset(columnIndex: i32): Asset;
    GetAssets(columnIndex: i32): Array<Asset>;
    GetValue(columnIndex: i32): ValueType;
    GetFloat32Array(columnIndex: i32): @typedarray Array<f32>;
    GetRow(): @record Map<String, ValueType>;
    GetCurrentRowData(): Array<ValueType>;
    @gen_promise("getRowsData")
    GetRowsDataSync(maxCount: i32, position: Optional<i32>): Array<Array<ValueType>>;
    IsColumnNull(columnIndex: i32): bool;
    Close(): void;
}

@class
interface RdbPredicates {
    GetSpecificImplPtr (): i64;
    InnerInDevices(devices: Array<String>): void;
    InnerInAllDevices(): void;
    InnerEqualTo(field: String, value: ValueType): void;
    InnerNotEqualTo(field: String, value: ValueType): void;
    InnerBeginWrap(): void;
    InnerEndWrap(): void;
    InnerOr(): void;
    InnerAnd(): void;
    InnerContains(field: String, value: String): void;
    InnerBeginsWith(field: String, value: String): void;
    InnerEndsWith(field: String, value: String): void;
    InnerIsNull(field: String): void;
    InnerIsNotNull(field: String): void;
    InnerLike(field: String, value: String): void;
    InnerGlob(field: String, value: String): void;
    InnerBetween(field: String, low: ValueType, high: ValueType): void;
    InnerNotBetween(field: String, low: ValueType, high: ValueType): void;
    InnerGreaterThan(field: String, value: ValueType): void;
    InnerLessThan(field: String, value: ValueType): void;
    InnerGreaterThanOrEqualTo(field: String, value: ValueType): void;
    InnerLessThanOrEqualTo(field: String, value: ValueType): void;
    InnerOrderByAsc(field: String): void;
    InnerOrderByDesc(field: String): void;
    InnerDistinct(): void;
    InnerLimitAs(value:i32): void;
    InnerOffsetAs(rowOffset: i32): void;
    InnerGroupBy(fields: Array<String>): void;
    InnerIndexedBy(field: String): void;
    InnerInValues(field: String, value: Array<ValueType>): void;
    InnerNotInValues(field: String, value: Array<ValueType>): void;
    InnerNotContains(field: String, value: String): void;
    InnerNotLike(field: String, value: String): void;
    InnerHaving(conditions: String, args: Optional<Array<ValueType>>): void;
    @!sts_inject_into_class("""
    
    inDevices(devices: Array<String>): RdbPredicates {
        this.innerInDevices(devices);
        return this;
    }
    inAllDevices(): RdbPredicates {
        this.innerInAllDevices();
        return this;
    }
    equalTo(field: String, value: ValueType): RdbPredicates {
        this.innerEqualTo(field, value);
        return this;
    }
    notEqualTo(field: String, value: ValueType): RdbPredicates {
        this.innerNotEqualTo(field, value);
        return this;
    }
    beginWrap(): RdbPredicates {
        this.innerBeginWrap();
        return this;
    }
    endWrap(): RdbPredicates {
        this.innerEndWrap();
        return this;
    }
    or(): RdbPredicates {
        this.innerOr();
        return this;
    }
    and(): RdbPredicates {
        this.innerAnd();
        return this;
    }
    contains(field: String, value: String): RdbPredicates {
        this.innerContains(field, value);
        return this;
    }
    beginsWith(field: String, value: String): RdbPredicates {
        this.innerBeginsWith(field, value);
        return this;
    }
    endsWith(field: String, value: String): RdbPredicates {
        this.innerEndsWith(field, value);
        return this;
    }
    isNull(field: String): RdbPredicates {
        this.innerIsNull(field);
        return this;
    }
    isNotNull(field: String): RdbPredicates {
        this.innerIsNotNull(field);
        return this;
    }
    like(field: String, value: String): RdbPredicates {
        this.innerLike(field, value);
        return this;
    }
    glob(field: String, value: String): RdbPredicates {
        this.innerGlob(field, value);
        return this;
    }
    between(field: String, low: ValueType, high: ValueType): RdbPredicates {
        this.innerBetween(field, low, high);
        return this;
    }
    notBetween(field: String, low: ValueType, high: ValueType): RdbPredicates {
        this.innerNotBetween(field, low, high);
        return this;
    }
    greaterThan(field: String, value: ValueType): RdbPredicates {
        this.innerGreaterThan(field, value);
        return this;
    }
    lessThan(field: String, value: ValueType): RdbPredicates {
        this.innerLessThan(field, value);
        return this;
    }
    greaterThanOrEqualTo(field: String, value: ValueType): RdbPredicates {
        this.innerGreaterThanOrEqualTo(field, value);
        return this;
    }
    lessThanOrEqualTo(field: String, value: ValueType): RdbPredicates {
        this.innerLessThanOrEqualTo(field, value);
        return this;
    }
    orderByAsc(field: String): RdbPredicates {
        this.innerOrderByAsc(field);
        return this;
    }
    orderByDesc(field: String): RdbPredicates {
        this.innerOrderByDesc(field);
        return this;
    }
    distinct(): RdbPredicates {
        this.innerDistinct();
        return this;
    }
    limitAs(value: int): RdbPredicates {
        this.innerLimitAs(value);
        return this;
    }
    offsetAs(rowOffset: int): RdbPredicates {
        this.innerOffsetAs(rowOffset);
        return this;
    }
    groupBy(fields: Array<String>): RdbPredicates {
        this.innerGroupBy(fields);
        return this;
    }
    indexedBy(field: String): RdbPredicates {
        this.innerIndexedBy(field);
        return this;
    }
    inValues(field: String, value: Array<ValueType>): RdbPredicates {
        this.innerInValues(field, value);
        return this;
    }
    notInValues(field: String, value: Array<ValueType>): RdbPredicates {
        this.innerNotInValues(field, value);
        return this;
    }
    notContains(field: String, value: String): RdbPredicates {
        this.innerNotContains(field, value);
        return this;
    }
    notLike(field: String, value: String): RdbPredicates {
        this.innerNotLike(field, value);
        return this;
    }
    having(conditions: String, args?: Array<ValueType>): RdbPredicates {
        this.innerHaving(conditions, args);
        return this;
    }
    """)
}

@ctor("RdbPredicates")
function CreateRdbPredicates(name : String): RdbPredicates;

interface Transaction {
    @gen_promise("commit")
    CommitSync(): void;

    @gen_promise("rollback")
    RollbackSync(): void;

    @gen_promise("insert")
    InsertSync(table: String, values: @record Map<String, ValueType>, conflict: Optional<ConflictResolution>): i64;

    @gen_promise("batchInsert")
    BatchInsertSync(table: String, values: Array<@record Map<String, ValueType>>): i64;

    @gen_promise("update")
    UpdateSync(values: @record Map<String, ValueType>, predicates: RdbPredicates, conflict: Optional<ConflictResolution>): i64;

    @gen_promise("delete")
    DeleteSync(predicates: RdbPredicates): i64;

    @gen_promise("query")
    QuerySync(predicates: RdbPredicates, columns: Optional<Array<String>>): ResultSet;

    @gen_promise("querySql")
    QuerySqlSync(sql: String, args: Optional<Array<ValueType>>): ResultSet;

    @gen_promise("queryWithoutRowCount")
    QueryWithoutRowCountSync(predicates: RdbPredicates, columns: Optional<Array<String>>): LiteResultSet;

    @gen_promise("querySqlWithoutRowCount")
    QuerySqlWithoutRowCountSync(sql: String, args: Optional<Array<ValueType>>): LiteResultSet;

    @gen_promise("execute")
    ExecuteSync(sql: String, args: Optional<Array<ValueType>>): ValueType;

    @gen_promise("batchInsertWithReturning")
    BatchInsertWithReturningSync(table: String, values: Array<ValuesBucket>, config: ReturningConfig, conflict: Optional<ConflictResolution>): Result;

    @gen_promise("updateWithReturning")
    UpdateWithReturningSync(values: ValuesBucket, predicates: RdbPredicates, config: ReturningConfig, conflict: Optional<ConflictResolution>): Result;

    @gen_promise("deleteWithReturning")
    DeleteWithReturningSync(predicates: RdbPredicates, config: ReturningConfig): Result;

@!sts_inject_into_class("""
    insertSync(table: string, values: Record<string, ValueType>) : long
    {
        return this.insertSync(table, values, undefined);
    }
    updateSync(values: Record<string, ValueType>, predicates: RdbPredicates): long
    {
        return this.updateSync(values, predicates, undefined);
    }
    querySync(predicates: RdbPredicates): ResultSet
    {
        return this.querySync(predicates, undefined);
    }
    querySqlSync(sql: string): ResultSet
    {
        return this.querySqlSync(sql, undefined);
    }
    executeSync(sql: string): ValueType
    {
        return this.executeSync(sql, undefined);
    }
    BatchInsertWithReturningSync(table: String, values: Array<ValuesBucket>, config: ReturningConfig): Result
    {
        return this.batchInsertWithReturningSync(table, values, config, undefined);
    }
    UpdateWithReturningSync(values: ValuesBucket, predicates: RdbPredicates, config: ReturningConfig): Result
    {
        return this.updateWithReturningSync(values, predicates, config, undefined);
    }
""")

    @gen_promise("batchInsertWithConflictResolution")
    BatchInsertWithConflictResolutionSync(table: String, values: Array<ValuesBucket>, conflict: ConflictResolution): i64;
}

interface RdbStore {
    @get GetVersion() : i32;
    @set SetVersion(veriosn : i32);

    @get GetRebuilt() : RebuildType;

    @gen_async("insert")
    @gen_promise("insert")
    InsertWithConflict(table: String, values: @record Map<String, ValueType>, conflict: ConflictResolution): i64;

    @gen_async("insert")
    @gen_promise("insert")
    InsertWithValue(table: String, values: @record Map<String, ValueType>) : i64;

    InsertSync(table: String, values: @record Map<String, ValueType>, conflict: Optional<ConflictResolution>): i64;

    @gen_async("batchInsert")
    @gen_promise("batchInsert")
    BatchInsertSync(table: String, values: Array<@record Map<String, ValueType>>): i64;

    @gen_async("update")
    @gen_promise("update")
    UpdateWithPredicate(values: @record Map<String, ValueType>, predicates: RdbPredicates): i64;

    @gen_async("update")
    @gen_promise("update")
    UpdateSync(values: @record Map<String, ValueType>, predicates: RdbPredicates, conflict: Optional<ConflictResolution>): i64;

    @gen_async("update")
    @gen_promise("update")
    UpdateDataShareSync(
      table: String,
      values: ValuesBucket,
      predicates: @sts_type("dataSharePredicates.DataSharePredicates") Opaque
    ): i64;

    @gen_async("delete")
    @gen_promise("delete")
    DeleteSync(predicates: RdbPredicates): i64;

    @gen_async("delete")
    @gen_promise("delete")
    DeleteDataShareSync(table: String, predicates: @sts_type("dataSharePredicates.DataSharePredicates") Opaque): i64;

    @gen_async("query")
    QueryWithPredicate(predicates: RdbPredicates) : ResultSet;

    @gen_async("query")
    QueryWithColumn(predicates: RdbPredicates, columns: Array<String>) : ResultSet;

    @gen_promise("query")
    QueryWithOptionalColumn(predicates: RdbPredicates, columns: Optional<Array<String>>) : ResultSet;

    @gen_async("query")
    QueryDataShareSync(table: String, predicates: @sts_type("dataSharePredicates.DataSharePredicates") Opaque) : ResultSet;

    @gen_async("query")
    @gen_promise("query")
    QueryDataShareWithColumnSync(
      table: String,
      predicates: @sts_type("dataSharePredicates.DataSharePredicates") Opaque,
      columns: Optional<Array<String>>) : ResultSet;

    QuerySync(predicates: RdbPredicates, columns: Optional<Array<String>>): ResultSet;

    @gen_async("querySql")
    QuerySqlWithSql(sql: String) : ResultSet;

    @gen_async("querySql")
    QuerySqlWithArgs(sql: String, bindArgs: Array<ValueType>) : ResultSet;

    @gen_promise("querySql")
    QuerySqlSync(sql: String, bindArgs: Optional<Array<ValueType>>): ResultSet;

    @gen_promise("queryWithoutRowCount")
    QueryWithoutRowCountSync(predicates: RdbPredicates, columns: Optional<Array<String>>): LiteResultSet;

    @gen_promise("querySqlWithoutRowCount")
    QuerySqlWithoutRowCountSync(sql: String, args: Optional<Array<ValueType>>): LiteResultSet;

    @gen_promise("getModifyTime")
    @gen_async("getModifyTime")
    GetModifyTimeSync(table: String, columnName: String, primaryKeys: Array<PRIKeyType>): ModifyTime;

    @gen_async("cleanDirtyData")
    CleanDirtyDataWithCursor(table: String, cursor: u64): void;

    @gen_async("cleanDirtyData")
    CleanDirtyDataWithTable(table: String): void;

    @gen_promise("cleanDirtyData")
    CleanDirtyDataWithOptionCursor(table: String, cursor: Optional<u64>): void;

    @gen_promise("querySharingResource")
    QuerySharingResourceWithOptionColumn(predicates: RdbPredicates, columns: Optional<Array<String>>): ResultSet;

    @gen_async("querySharingResource")
    QuerySharingResourceWithPredicate(predicates: RdbPredicates): ResultSet;

    @gen_async("querySharingResource")
    QuerySharingResourceWithColumn(predicates: RdbPredicates, columns: Array<String>): ResultSet;

    @gen_async("executeSql")
    ExecuteSqlWithSql(sql: String): void;

    @gen_async("executeSql")
    ExecuteSqlWithArgs(sql: String, bindArgs: Array<ValueType>): void;

    @gen_promise("executeSql")
    ExecuteSqlWithOptionArgs(sql: String, bindArgs: Optional<Array<ValueType>>): void;

    @gen_promise("execute")
    ExecuteWithOptionArgs(sql: String, args: Optional<Array<ValueType>>): ValueType;

    @gen_promise("execute")
    ExecuteWithTxId(sql: String, txId: i64, args: Optional<Array<ValueType>>): ValueType;

    ExecuteSync(sql: String, args: Optional<Array<ValueType>>): ValueType;

    BeginTransaction(): void;

    @gen_promise("beginTrans")
    BeginTransSync(): i64;

    Commit(): void;

    @gen_promise("commit")
    CommitWithTxId(txId : i64): void;

    RollBack(): void;

    @gen_promise("rollback")
    RollbackSync(txId : i64): void;

    @gen_async("backup")
    @gen_promise("backup")
    BackupSync(destName: String): void;

    @gen_async("restore")
    @gen_promise("restore")
    RestoreWithSrcName(srcName: String): void;

    @gen_promise("restore")
    RestoreWithVoid(): void;

    @gen_async("setDistributedTables")
    @gen_promise("setDistributedTables")
    SetDistributedTablesWithTables(tables: Array<String>): void;

    @gen_async("setDistributedTables")
    SetDistributedTablesWithType(tables: Array<String>, type: DistributedType): void;

    @gen_async("setDistributedTables")
    SetDistributedTablesWithConfig(
      tables: Array<String>,
      type: DistributedType,
      config: DistributedConfig
    ): void;

    @gen_promise("setDistributedTables")
    SetDistributedTablesWithOptionConfig(tables: Array<String>, type: Optional<DistributedType>, config: Optional<DistributedConfig>): void;

    @gen_async("obtainDistributedTableName")
    @gen_promise("obtainDistributedTableName")
    ObtainDistributedTableNameSync(device: String, table: String): String;

    @rename("sync")
    SyncPromise(mode: SyncMode, predicates: RdbPredicates): @sts_type("Promise<Array<[string, int]>>") Opaque;
    @rename("sync")
    SyncAsync(mode: SyncMode, predicates: RdbPredicates, callback: @sts_type("AsyncCallback<Array<[string, int]>>") Opaque): void;

    @gen_async("cloudSync")
    @gen_promise("cloudSync")
    CloudSyncWithProgress(mode: SyncMode, progress: (p : ProgressDetails) => void): void;

    @gen_async("cloudSync")
    @gen_promise("cloudSync")
    CloudSyncWithTable(mode: SyncMode, tables: Array<String>, progress: (p : ProgressDetails) => void): void;

    @gen_async("cloudSync")
    @gen_promise("cloudSync")
    CloudSyncWithPredicates(mode: SyncMode, predicates: RdbPredicates, progress: (p : ProgressDetails) => void): void;

    @gen_async("remoteQuery")
    @gen_promise("remoteQuery")
    RemoteQuerySync(device: String, table: String, predicates: RdbPredicates, columns: Array<String>): ResultSet;

    @gen_promise("batchInsertWithReturning")
    BatchInsertWithReturningSync(table: String, values: Array<ValuesBucket>, config: ReturningConfig, conflict: Optional<ConflictResolution>): Result;

    @gen_promise("updateWithReturning")
    UpdateWithReturningSync(values: ValuesBucket, predicates: RdbPredicates, config: ReturningConfig, conflict: Optional<ConflictResolution>): Result;

    @gen_promise("deleteWithReturning")
    DeleteWithReturningSync(predicates: RdbPredicates, config: ReturningConfig): Result;

    @!sts_inject_into_interface("""
        onDataChange(type: SubscribeType, callback: (((info: Array<ChangeInfo>) => void) | ((info: Array<String>) => void))): void;
        onAutoSyncProgress(callback: (info: ProgressDetails) => void): void;
        onStatistics(callback: (info: SqlExecutionInfo) => void): void;
        on(event: string, interProcess: boolean, callback: (arg: undefined) => void): void;
        onSqliteErrorOccurred(observer: (info: ExceptionMessage) => void): void;
        onPerfStat(observer: (info: SqlExecutionInfo) => void): void;
        offDataChange(type: SubscribeType, callback?: (info: Array<String> | Array<ChangeInfo>) => void): void;
        offAutoSyncProgress(callback?: (info: ProgressDetails) => void): void;
        offStatistics(callback?: (info: SqlExecutionInfo) => void): void;
        off(event: string, interProcess: boolean, callback?: (arg: undefined) => void): void;
        offSqliteErrorOccurred(observer?: (info: ExceptionMessage) => void): void;
        offPerfStat(observer?: (info: SqlExecutionInfo) => void): void;
    """)

    @!sts_inject_into_class("""
        insertSync(table: string, values: Record<string, ValueType>): long
        {
            return this.insertSync(table, values, undefined);
        }
        updateSync(values: Record<string, ValueType>, predicates: RdbPredicates): long
        {
            return this.updateSync(values, predicates, undefined);
        }
        querySync(predicates: RdbPredicates): ResultSet
        {
            return this.querySync(predicates, undefined);
        }
        querySqlSync(sql: string): ResultSet
        {
            return this.querySqlSync(sql, undefined);
        }
        executeWithTxId(sql: string, txId: long): ValueType
        {
           return this.executeWithTxId(sql, txId, undefined);
        }
        executeSync(sql: string): ValueType
        {
            return this.executeSync(sql, undefined);
        }
        createTransactionSync(): Transaction
        {
            return this.createTransactionSync(undefined);
        }

        onDataChange(type: SubscribeType, cb: Object) : void {
            switch (type) {
                case SubscribeType.SUBSCRIBE_TYPE_CLOUD_DETAILS:
                case SubscribeType.SUBSCRIBE_TYPE_LOCAL_DETAILS:
                    return this.onDataChangeWithChangeInfo(type, cb as (info: Array<ChangeInfo>) => void, cb);
                case SubscribeType.SUBSCRIBE_TYPE_REMOTE:
                case SubscribeType.SUBSCRIBE_TYPE_CLOUD:
                    return this.onDataChangeWithDevices(type, cb as (info: Array<String>) => void, cb);
                default: throw new Error(`Unknown type: ${type}`);
            }
        }

        offDataChange(type: SubscribeType, cb?: Object) : void {
            return this.offDataChangeInner(type, cb);
        }

        onAutoSyncProgress(cb: Object) : void {
            this.onAutoSyncProgressInner(cb as (info: ProgressDetails) => void, cb);
        }
        onStatistics(cb: Object) : void {
            return this.onStatisticsInner(cb as (info: SqlExecutionInfo) => void, cb);
        }
        offAutoSyncProgress(cb?: Object) : void {
            return this.offAutoSyncProgressInner(cb);
        }
        offStatistics(cb?: Object) : void {
            return this.offStatisticsInner(cb);
        }

        on(event: String, interProcess: boolean, cb: Object) : void {
          return this.onCommon(event, interProcess, cb as () => void, cb);
        }

        off(event: String, interProcess: boolean, cb?: Object) : void {
          return this.offCommon(event, interProcess, cb);
        }

        onSqliteErrorOccurred(observer: Object): void {
            this.onSqliteErrorOccurredInner(observer as (info: ExceptionMessage) => void, observer);
        }
        offSqliteErrorOccurred(observer?: Object): void {
            return this.offSqliteErrorOccurredInner(observer);
        }

        onPerfStat(observer: Object): void {
            this.onPerfStatInner(observer as (info: SqlExecutionInfo) => void, observer);
        }
        offPerfStat(observer?: Object): void {
            return this.offPerfStatInner(observer);
        }

        BatchInsertWithReturningSync(table: String, values: Array<ValuesBucket>, config: ReturningConfig): Result
        {
            return this.batchInsertWithReturningSync(table, values, config, undefined);
        }

        UpdateWithReturningSync(values: ValuesBucket, predicates: RdbPredicates, config: ReturningConfig): Result
        {
            return this.updateWithReturningSync(values, predicates, config, undefined);
        }
    """)

    OnDataChangeWithChangeInfo(type: SubscribeType, f: (info: Array<ChangeInfo>) => void, opq: Opaque) : void;
    OnDataChangeWithDevices(type: SubscribeType, f: (info: Array<String>) => void, opq: Opaque) : void;
    OffDataChangeInner(type: SubscribeType, opq: Optional<Opaque>) : void;

    OnAutoSyncProgressInner(f: (info: ProgressDetails) => void, opq: Opaque) : void;
    OffAutoSyncProgressInner(opq: Optional<Opaque>) : void;

    OnStatisticsInner(f: (info : SqlExecutionInfo) => void, opq: Opaque) : void;
    OffStatisticsInner(opq: Optional<Opaque>) : void;

    OnCommon(event: String, interProcess: bool, f: () => void, opq: Opaque) : void;
    OffCommon(event: String, interProcess: bool, opq: Optional<Opaque>) : void;

    OnSqliteErrorOccurredInner(observer: (info: ExceptionMessage) => void, opq: Opaque): void;
    OffSqliteErrorOccurredInner(opq: Optional<Opaque>): void;

    OnPerfStatInner(observer: (info: SqlExecutionInfo) => void, opq: Opaque): void;
    OffPerfStatInner(opq: Optional<Opaque>): void;

    Emit(event: String): void;

    @gen_promise("close")
    CloseSync(): void;

    @gen_promise("attach")
    AttachWithWaitTime(fullPath: String, attachName: String, waitTime: Optional<i32>) : i32;

    @gen_promise("attach")
    AttachWithContext(context: @sts_type("BaseContext") Opaque, config: StoreConfig, attachName: String, waitTime: Optional<i32>) : i32;

    @gen_promise("detach")
    DetachSync(attachName: String, waitTime: Optional<i32>) : i32;

    @gen_promise("lockRow")
    LockRowSync(predicates: RdbPredicates): void;

    @gen_promise("unlockRow")
    UnlockRowSync(predicates: RdbPredicates): void;

    @gen_promise("queryLockedRow")
    QueryLockedRowSync(predicates: RdbPredicates, columns: Optional<Array<String>>): ResultSet;

    @gen_promise("lockCloudContainer")
    LockCloudContainerSync(): u32;

    @gen_promise("unlockCloudContainer")
    UnlockCloudContainerSync(): void;

    @gen_promise("createTransaction")
    CreateTransactionSync(options: Optional<TransactionOptions>): Transaction;

    @gen_promise("batchInsertWithConflictResolution")
    BatchInsertWithConflictResolutionSync(table: String, values: Array<ValuesBucket>, conflict: ConflictResolution): i64;

    @gen_promise("rekey")
    RekeySync(cryptoParam: Optional<CryptoParam>): void;

    @gen_promise("rekeyEx")
    RekeyExSync(cryptoParam: CryptoParam): void;

    @gen_promise("setLocale")
    SetLocaleSync(locale: String) : void;
}

@gen_async("getRdbStore")
@gen_promise("getRdbStore")
function GetRdbStoreSync(context: @sts_type("BaseContext") Opaque, config: StoreConfig): RdbStore;

@gen_async("deleteRdbStore")
@gen_promise("deleteRdbStore")
function DeleteRdbStoreWithName(context: @sts_type("BaseContext") Opaque, name: String): void;

@gen_async("deleteRdbStore")
@gen_promise("deleteRdbStore")
function DeleteRdbStoreWithConfig(context: @sts_type("BaseContext") Opaque, config: StoreConfig): void;

function IsVectorSupported(): bool;

function IsTokenizerSupported(tokenizer: Tokenizer): bool;

function GetInsertSqlInfo(table: String, values: ValuesBucket, conflict: Optional<ConflictResolution>): SqlInfo;

function GetUpdateSqlInfo(predicates: RdbPredicates, values: ValuesBucket, conflict: Optional<ConflictResolution>): SqlInfo;

function GetDeleteSqlInfo(predicates: RdbPredicates): SqlInfo;

function GetQuerySqlInfo(predicates: RdbPredicates, columns: Optional<Array<String>>): SqlInfo;